# -*- coding: utf-8 -*-
"""TrabajoFinal-Hito2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qMqekUADBBbKR-697Cjk8PYpsyNRoxkP

### Functions for calculate distance between 2 coordenates and convert graphs from networkx to graphviz
"""

import networkx as nx
import graphviz as gv
import heapq as hq 
from heapq import heappush as push, heappop as pop
import math 
def nxtogv(G, weighted=False, params={'rankdir': 'LR', 'size': '6'},
          path=None, pathparams={'color':'orangered', 'penwidth': '3'},
          nodeinfo=False):
  if G.is_directed():
    g = gv.Digraph('G')
    
  else:
    g = gv.Graph('G')
    
  g.attr(**params)

  for u in G.nodes:
    if nodeinfo:
      g.node(str(u), **dict(G.nodes[u]))
    else:
      g.node(str(u))

  for u, v in G.edges():
    if G.is_directed():
      pp = pathparams if path and path[v] == u else {}
    else:
      pp = pathparams if (path and path[v] == u) or (path and path[u] == v) else {}

    if weighted:
      g.edge(str(u), str(v), f"{G.edges[u, v]['weight']}", **pp)
    else:
      g.edge(str(u), str(v), **pp)
      
  return g

def distance(c1,c2):
  la1, lo1 = float(c1['LATITUD']), float(c1['LONGITUD'])
  la2, lo2 = float(c2['LATITUD']), float(c2['LONGITUD'])
  
  lo1, la1, lo2, la2 = map(math.radians, [lo1, la1, lo2, la2])
  dlo = lo2 - lo1
  dla = la2 - la1
  a = math.sin(dla/2)**2 + math.cos(la1) * math.cos(la2) * math.sin(dlo/2)**2
  c = 2 * math.asin(math.sqrt(a))
  r = 6371

  return round(c * r, 2)

"""Reading data from csv"""

import pandas as pd
import numpy as np

csvUrl="https://raw.githubusercontent.com/draul99/traveling_data/main/data.csv"

data = pd.read_csv(csvUrl)
pd.set_option('display.max_rows',None)
data

def get_Data4Colum(ColumnKey, data):
  prov_names = data[ColumnKey].unique()
  print("Total",ColumnKey.lower()+"s","halladas: ", len(prov_names))
  return prov_names



name_provs=get_Data4Colum('PROVINCIA',data)
name_deps=get_Data4Colum('DEPARTAMENTO',data)
name_distr=get_Data4Colum('DISTRITO',data)
name_cp=get_Data4Colum('CENTRO POBLADO',data)

provinces = dict()
counter = 0
print('Poblated Center in each province\n' )
for name in name_provs:
  counter+=1
  provinces[name] = data[data['PROVINCIA']== name]
  print(name, len(provinces[name]))
print(counter)

#@title Province
#@markdown Enter the province

no_type_checking = ''
name_province = 'BONGARA' #@param {type: "string"}

name_distritcs = provinces[name_province]['DISTRITO'].unique()
print('The districts of the ',name_province, 'province are ',len(name_distritcs), ':')
print(name_distritcs)

districts = dict()
for name in name_distritcs:
  districts[name]=provinces[name_province][provinces[name_province]['DISTRITO']==name]
  print(name,len(districts[name]))

"""POPULATIONS CENTERS OF SPECIFIC DISTRICT"""

#@title District
#@markdown Enter the district name
no_type_checking = ''
name_dist = 'JAZAN' #@param {type: "string"}

"""### Load Nodes and Edges from Data"""

district = districts[name_dist]
G = nx.Graph()
col = 'CENTRO POBLADO'
index = district.index[0]
for i, cp1 in district.iterrows():
    G.add_node(i, label=cp1[col])
for i, cp1 in district.iterrows():
    for j, cp2 in district.iterrows():
        if cp1[col] != cp2[col]: 
            G.add_edge(i, j, weight=distance(cp1, cp2))

#@title Graph of population centers of 

nxtogv(G,nodeinfo=True, weighted=True, params={'size':'20'})

"""###Fuerza Bruta Algorithm"""

def menor(G,s):
  z = []
  for i in G.neighbors(s):
    x = G.edges[s,i]['weight']
    z.append(x)
    z.sort()
  return min(z)
  
def bruteforce(G, s):
  P = nx.Graph(G)
  L = nx.Graph(G)
  x = []
  queue = [s]
  camino = [s]
  for u in G.nodes:
    G.nodes[u]['visited'] = False
    G.nodes[u]['path'] = -1
  G.nodes[s]['visited'] = True
  while queue:
    u = queue[0]
    for v in G.neighbors(u):
      if not G.nodes[v]['visited'] and L.edges[u,v]['weight'] == menor(L,u):
        x.append(menor(L,u))
        G.nodes[v]['visited'] = True
        G.nodes[v]['path'] = u
        camino.append(v)
        queue.append(v)
    L.remove_node(queue[0])
    del queue[0]
  costo =sum(x)
  return camino, costo

"""###Depth-First Search Algorithm"""

def _dfs(G, u, cam, sig):
    if not G.nodes[u]['visited']:
        min = math.inf
        G.nodes[u]['visited'] = True
        cam.append(u)
        for v in G.neighbors(u):
            for edge in G.edges(u):
                if v == edge[1] and G.edges[u, v]['weight'] < min and not G.nodes[v]['visited']:
                    min = G.edges[u, v]['weight']
                    sig = v
        if sig != u:
          G.nodes[sig]['path'] = u
          _dfs(G, sig, cam, sig)



def dfs(G, s):
    camino = []
    sig = s
    for u in G.nodes:
        G.nodes[u]['visited'] = False
        G.nodes[u]['path'] = -1
    _dfs(G, s, camino, sig)
    ultimo = camino[-1]
    print(f"El camino es el siguiente {camino}")
    return ultimo